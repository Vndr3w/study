# Домашнее задание к занятию «Базы данных, их типы» - Лукинов Андрей

## Кейс
Крупная строительная компания, которая также занимается проектированием и девелопментом, решила создать правильную архитектуру для работы с данными. Ниже представлены задачи которые необходимо решить для каждой предметной области. 

## Задание 1. СУБД

  Какие типы СУБД, на ваш взгляд, лучше всего подойдут для решения этих задач и почему? 
 
  1.1. Бюджетирование проектов с дальнейшим формированием финансовых аналитических отчётов и прогнозирования рисков. СУБД должна гарантировать целостность и чёткую структуру данных.

  - Для бюджетирования с формированием финансовых отчетов и прогнозирования рисков оптимально подойдет реляционная СУБД. Она гарантирует целостность и чёткую структуру данных. 

  1.1.* Хеширование стало занимать длительно время, какое API можно использовать для ускорения работы?

  - Увеличить work_mem
    - Параметр work_mem определяет максимальный объем памяти для операций сортировки и хеширования перед записью данных на диск. По умолчанию установлено 4 МБ, что часто недостаточно для больших таблиц. Когда hash-таблица не помещается в work_mem, PostgreSQL разбивает ее на батчи и записывает во временные файлы на диске, что резко снижает производительность.
  - Использовать hash_mem_multiplier
    - PostgreSQL предоставляет специальный множитель для hash-операций, позволяющий выделить им больше памяти, чем указано в work_mem. Это позволяет тонко настроить производительность без увеличения памяти для всех операций.
  - Создать расширенную статистику
    - PostgreSQL может выбирать неоптимальный Hash Join вместо более эффективного Nested Loop из-за неточных оценок. Использование расширенной статистики решает эту проблему.
  - Применить pgcrypto с AES-NI
    - Для криптографического хеширования паролей (SHA-256, SHA-512) в PostgreSQL используется расширение pgcrypto. Intel AES-NI обеспечивает аппаратное ускорение, которое дает 3-10-кратное увеличение производительности по сравнению с программной реализацией.
  - Включить parallel hash join
    - PostgreSQL 9.6+ поддерживает параллельные hash join, которые строят общую hash-таблицу для всех worker-процессов. Простой алгоритм без партиционирования данных показывает лучшую производительность при увеличении skew (асимметрии) в данных.
  
  1.2. Под каждый девелоперский проект создаётся отдельный лендинг, и все данные по лидам стекаются в CRM к маркетологам и менеджерам по продажам. Какой тип СУБД лучше использовать для лендингов и для CRM? СУБД должны быть гибкими и быстрыми.

  - Для лендингов: MongoDB или другая документоориентированная NoSQL СУБД
    - Лендинги требуют гибкости структуры данных и высокой скорости записи лидов. MongoDB предоставляет динамическую схему, оптимизированную для быстрой записи данных, и поддерживает данные в формате JSON.
  - Для CRM: PostgreSQL с поддержкой JSONB
    - CRM-система нуждается в балансе между гибкостью и надежностью транзакций. PostgreSQL с типом данных JSONB позволяет сочетать преимущества реляционной модели с гибкостью документоориентированного хранения.

  1.2.* Можно ли эту задачу закрыть одной СУБД? И если да, то какой именно СУБД и какой реализацией?
  
  - Задачу можно закрыть одной СУБД - PostgreSQL. Для лендингов использовать таблицы с JSONB-полями для хранения динамических атрибутов лидов, а для CRM - классические реляционные таблицы с внешними ключами для обеспечения целостности данных.​

  1.3. Отдел контроля качества решил создать базу по корпоративным нормам и правилам, обучающему материалу и так далее, сформированную согласно структуре компании. СУБД должна иметь простую и понятную структуру.

  - Для организации документации по структуре компании подходит СУБД с поддержкой иерархических структур. PostgreSQL с использованием рекурсивных запросов (CTE) и материализованных путей позволяет эффективно моделировать иерархию документов согласно организационной структуре. Альтернативно можно использовать MongoDB для хранения документов с вложенной структурой.

  1.3.* Можно ли под эту задачу использовать уже существующую СУБД из задач выше и если да, то как лучше это реализовать?

  - Можно использовать PostgreSQL из задачи 1.1 или 1.2. Реализация: создать отдельную схему (schema) для изоляции данных департамента контроля качества, использовать тип LTREE для хранения иерархических путей или рекурсивные CTE для построения древовидной структуры документации.

  1.4. Департамент логистики нуждается в решении задач по быстрому формированию маршрутов доставки материалов по объектам и распределению курьеров по маршрутам с доставкой документов. СУБД должна уметь быстро работать со связями.

  - Для быстрого формирования маршрутов доставки и распределения курьеров оптимальна графовая СУБД. Neo4j со встроенной библиотекой Graph Data Science позволяет эффективно применять алгоритм Дейкстры для поиска кратчайших путей. Графовые базы данных обеспечивают прямые связи без необходимости JOIN-операций, что критично для задач логистики.

  1.4.* Можно ли к этой СУБД подключить отдел закупок или для них лучше сформировать свою СУБД в связке с СУБД логистов?

  - Рекомендуется создать отдельную реляционную СУБД (PostgreSQL) для отдела закупок с интеграцией к графовой СУБД логистов. Закупки требуют строгой транзакционности и целостности данных (ACID), что лучше обеспечивают реляционные СУБД. Связь можно реализовать через API или ETL-процессы для синхронизации данных о материалах и маршрутах.

  1.5.* Можно ли все перечисленные выше задачи решить, используя одну СУБД? Если да, то какую именно?

  - Теоретически все задачи можно решить на PostgreSQL. Эта СУБД поддерживает реляционную модель для бюджетирования и CRM, JSONB для гибких схем лендингов, рекурсивные запросы для иерархий документации, и расширение pgRouting для базовых задач маршрутизации. Однако для сложных логистических задач производительность будет ниже, чем у специализированных графовых СУБД. Оптимальный подход - использовать PostgreSQL как основную СУБД для большинства задач с добавлением специализированной графовой СУБД для департамента логистики.

## Задание 2. Транзакции

  2.1. Пользователь пополняет баланс счёта телефона, распишите пошагово, какие действия должны произойти для того, чтобы транзакция завершилась успешно. Ориентируйтесь на шесть действий.

  - Успешная транзакция пополнения баланса мобильного телефона включает следующие шесть шагов, основанных на принципах ACID:

    1. *Начало транзакции*
         - Система инициирует транзакцию и создает точку сохранения (savepoint), к которой можно откатиться в случае ошибки. На этом этапе устанавливаются блокировки на записи в базе данных для предотвращения конфликтов с другими параллельными операциями.
    2. *Проверка баланса источника средств*
         - Система проверяет наличие достаточных средств на банковском счете или карте плательщика. Если баланс недостаточен, выполняется ROLLBACK и транзакция отменяется полностью.
    3. *Списание средств с источника*
         - Происходит уменьшение баланса банковского счета или карты на сумму платежа. Эта операция выполняется в рамках транзакции и остается в промежуточном состоянии до COMMIT.
    4. *Проверка существования получателя*
         - Система верифицирует существование номера телефона в базе данных оператора связи. Если номер не найден или заблокирован, транзакция откатывается.
    5. *Зачисление средств на баланс телефона*
         - Выполняется увеличение баланса мобильного счета на сумму платежа. Обе операции (списание и зачисление) формируют атомарную единицу - либо выполняются обе, либо ни одна.
    6. *Подтверждение транзакции*
         - Если все предыдущие шаги выполнены успешно, изменения фиксируются в базе данных навсегда командой COMMIT. После успешного коммита изменения сохраняются даже при сбое системы благодаря свойству Durability (устойчивости) ACID.

  2.1.* Какие действия должны произойти, если пополнение счёта телефона происходило бы через автоплатёж?

  - При автоматическом пополнении через автоплатеж добавляются следующие специфические механизмы:

    1. *Идемпотентность операций*
         - Система проверяет уникальный идентификатор транзакции (requestId) перед выполнением, чтобы предотвратить повторное списание при сбоях. Если транзакция с таким requestId уже выполнена, повторный запрос игнорируется.
    2. *Проверка условий срабатывания*
         - Система проверяет условия автоплатежа: минимальный баланс для пополнения, дату следующего платежа или порог срабатывания. Только при выполнении условий инициируется основная транзакция.
    3. *Компенсирующие транзакции*
         - В распределенных системах (банк + оператор связи) используется паттерн SAGA с компенсирующими действиями на случай частичного сбоя. Если зачисление на телефон не удалось, система автоматически возвращает средства на банковский счет.
    4. *Логирование для аудита*
         - Все этапы автоплатежа записываются в лог транзакций с временными метками для последующего анализа и разрешения споров. Это обеспечивает возможность отследить каждый автоматический платеж.​
    5. *Уведомление клиента*
         - После успешного COMMIT отправляется асинхронное уведомление клиенту о выполненном автоплатеже через SMS, push-уведомление или email. Эта операция выполняется вне основной транзакции для избежания блокировок.

## Задание 3. SQL vs NoSQL

  3.1. Напишите пять преимуществ SQL-систем по отношению к NoSQL. 

  - SQL-системы обладают рядом существенных преимуществ, которые делают их предпочтительным выбором для многих критичных бизнес-приложений.

    1. *Полная поддержка ACID-транзакций*
         - SQL-базы данных гарантируют строгую согласованность после каждой транзакции, соблюдая все правила целостности данных. Атомарность обеспечивает выполнение операций по принципу "все или ничего", согласованность переводит БД из одного корректного состояния в другое, изолированность предотвращает конфликты параллельных транзакций, а долговечность сохраняет результаты даже при сбоях системы. NoSQL-системы чаще используют модель BASE с eventual consistency (согласованностью в конечном счете), что недостаточно для транзакционных приложений вроде банкинга.
    2. *Структурированность и целостность данных*
         - SQL-базы данных имеют фиксированную схему с четкой структурой таблиц, внешними ключами и ограничениями целостности. Это предотвращает некорректные данные на уровне СУБД и обеспечивает предсказуемость структуры. В NoSQL отсутствие жесткой схемы может привести к трудностям с управлением данными и их согласованностью.​
    3. *Мощный язык запросов для сложной аналитики*
         - SQL предоставляет развитый стандартизированный язык для выполнения сложных запросов с множественными JOIN, подзапросами, агрегациями и аналитическими функциями. Это делает SQL оптимальным выбором для сложных запросов, связанных с большим количеством таблиц и требующих глубокого анализа данных. NoSQL имеет более простой язык запросов, который хорошо подходит для простых операций, но ограничен в сложных аналитических сценариях.
    4. *Зрелость и стандартизация*
         - SQL-системы существуют десятилетиями и имеют высокую степень зрелости, стандартизации и обширную экосистему инструментов. Большинство разработчиков знакомы с SQL, что упрощает найм специалистов и поддержку системы. Единый стандарт SQL облегчает миграцию между разными СУБД и интеграцию с BI-инструментами.
    5. *Надежность для критичных бизнес-процессов*
         - SQL-базы данных обеспечивают предсказуемое поведение и гарантии сохранности данных, что критично для финансовых систем, бюджетирования, ERP и других корпоративных приложений. Механизм блокировок и MVCC (многоверсионный контроль конкурентности) предотвращают аномалии чтения и гарантируют корректность результатов при параллельных операциях. NoSQL жертвует этими гарантиями ради производительности и доступности.

  3.1.* Какие, на ваш взгляд, преимущества у NewSQL систем перед SQL и NoSQL.

  - NewSQL-системы представляют собой современный класс СУБД, объединяющий сильные стороны SQL и NoSQL.
  
    1. *Горизонтальная масштабируемость с сохранением ACID*
         - NewSQL обеспечивает легкое горизонтальное масштабирование через архитектуру shared-nothing, где каждый узел независим и самодостаточен. При этом полностью сохраняется поддержка ACID-транзакций, в отличие от NoSQL, что позволяет масштабировать критичные приложения без потери целостности данных.
    2. *Многократное увеличение производительности*
         - Производительность узла NewSQL в 50 раз превышает традиционные СУБД благодаря архитектурным оптимизациям и механизму управления без блокировок. Это превосходит как классический SQL (медленный при больших нагрузках), так и NoSQL (быстрый, но без транзакционных гарантий).
    3. *Сохранение SQL-интерфейса*
         - NewSQL использует стандартный SQL как основной механизм взаимодействия, в отличие от NoSQL с проприетарными API. Это позволяет использовать существующие навыки команды, инструменты бизнес-аналитики и упрощает миграцию приложений.
    4. *Отсутствие конфликтов чтения-записи*
         - Механизм управления без применения блокировок обеспечивает, что операции чтения в реальном времени не конфликтуют с записью. Это решает проблему традиционных SQL-систем, где блокировки снижают параллелизм, превосходя производительность классических СУБД.
    5. *Распределённая архитектура для отказоустойчивости*
         - NewSQL обеспечивает высокую доступность через распределенную архитектуру с автоматической репликацией, сочетая отказоустойчивость NoSQL с консистентностью SQL. Это решает проблему вертикального масштабирования традиционных SQL-систем и отсутствия строгой согласованности в NoSQL.

## Задание 4. Кластеры

  Необходимо производить большое количество вычислений при работе с огромным количеством данных, под эту задачу выделено 1000 машин. На основе какого критерия будете выбирать тип СУБД и какая модель *распределённых вычислений* здесь справится лучше всего и почему?

  - Для обработки огромных объемов данных на кластере из 1000 машин выбор СУБД и модели распределенных вычислений зависит от критических характеристик задачи.​
  - Критерии выбора типа СУБД

    1. *Объем обрабатываемых данных*
         - Для кластера из 1000 узлов критичен объем данных, который необходимо обрабатывать. MPP-системы (Massively Parallel Processing) эффективны для объемов до сотен терабайт на кластерах до 100-200 узлов, в то время как Hadoop-based решения масштабируются до тысяч узлов и десятков петабайт. При 1000 машинах задача явно выходит за рамки типичных MPP-сценариев, что указывает на необходимость Hadoop-экосистемы или специализированных OLAP-решений.
    2. *Латентность запросов vs пропускная способность*
         - MPP-системы обеспечивают латентность запросов 10-20 миллисекунд и среднее время выполнения 5-7 секунд, но максимальная конкурентность составляет десятки-сотни запросов. Hadoop обеспечивает латентность 10-20 секунд, среднее время выполнения 10-15 минут, но поддерживает конкурентность лишь 10-20 задач. Выбор зависит от того, нужны ли интерактивные запросы или пакетная обработка больших объемов.
    3. *Тип вычислительной нагрузки*
         - Для аналитических вычислений (OLAP) подходят колоночные СУБД вроде ClickHouse или Greenplum, оптимизированные для агрегаций по большим объемам данных. Для сложных итеративных вычислений (машинное обучение, графовые алгоритмы) предпочтительнее фреймворк Apache Spark с его возможностью кэширования в памяти.
    4. *Отказоустойчивость и надежность*
         - Hadoop обеспечивает высокую отказоустойчивость за счет репликации блоков данных минимум на 3 узла. Задача падает только при сбое управляющего узла, в то время как в MPP сбой любого узла приводит к падению всего запроса. Для кластера из 1000 машин вероятность сбоев высока, что делает Hadoop более подходящим выбором.
  
  - Оптимальная модель распределенных вычислений
    - *Apache Spark - лучший выбор для 1000 узлов*
      - Для кластера из 1000 машин с интенсивными вычислениями оптимальна модель Apache Spark. Spark превосходит классический Hadoop MapReduce по нескольким параметрам.
  
  - Преимущества Spark перед MapReduce:
    1. *In-Memory вычисления*
         - Spark хранит промежуточные результаты в оперативной памяти (RAM), в то время как MapReduce записывает их на диск после каждого этапа Map и Reduce. Это обеспечивает ускорение в 10-100 раз для итеративных алгоритмов и машинного обучения.
    2. *Устранение блокировки между этапами*
         - В MapReduce все процессы Map должны завершиться перед началом Reduce, что создает задержки. Spark использует DAG (направленный ациклический граф) для оптимизации выполнения и позволяет выполнять операции параллельно без жесткой последовательности.
    3. *Поддержка сложных вычислительных паттернов*
         - MapReduce эффективен только для простых пакетных вычислений. Spark поддерживает множество моделей: пакетную обработку, потоковые вычисления (Spark Streaming), машинное обучение (MLlib), графовые вычисления (GraphX) и SQL-запросы (Spark SQL).​
    4. *Гибкая настройка ресурсов*
         - Spark позволяет точно настроить распределение вычислений через параметры количества исполнителей, памяти для каждого и ядер процессора.